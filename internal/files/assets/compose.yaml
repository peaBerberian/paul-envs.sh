# compose.yaml file
# =================
#
# If you plan to just set-up a single container for a single project,
# you can just create a .env file locally setting the env variables needed by
# this compose file, and add e.g. ports and volumes you would like.
#
# All expected environment variables (many with defaults) are listed in the
# `args` of the `paulenv` service which are fully documented if you want to
# go directly through the `docker compose` route.
#
# If building directly from `docker compose build`, don't forget to first
# initialize the "cache" docker volume:
# ```sh
# docker volume create paulenv-shared-cache 2>/dev/null || true
# ``
# And after a `build`, to initialize persisted volumes:
# ```sh
# `docker compose --profile reset up reset-cache reset-local`
# ```
#
# If you don't mind running the `paul-envs` binary, none of this is necessary,
# the `paul-envs` tool extends this compose.yaml file into other more refined
# compose files and auto-fills the right parameters.

services:

  paulenv:
    image: paulenv:latest
    pull_policy: never
    stdin_open: true
    tty: true
    build:
      context: .
      dockerfile: Dockerfile

      args:
        # To align with your current uid.
        # This is to ensure the mounted volume from your host has compatible
        # permissions.
        # On POSIX-like systems, just run `id -u` with the wanted user to know it.
        HOST_UID: ${HOST_UID:-1000}

        # To align with your current gid (same reason than for `uid`).
        # On POSIX-like systems, just run `id -g` with the wanted user to know it.
        HOST_GID: ${HOST_GID:-1000}

        # Username created in the container.
        # Not really important, just set it if you want something other than `dev`.
        USERNAME: ${USERNAME:-dev}

        # The default shell wanted.
        # Only `bash`, `zsh` or `fish` are supported for now.
        USER_SHELL: ${USER_SHELL:-bash}

        # Tools toggle.
        # `true` == install it, anything else == don't.
        INSTALL_NEOVIM: ${INSTALL_NEOVIM:-false}
        INSTALL_STARSHIP: ${INSTALL_STARSHIP:-false}
        INSTALL_ATUIN: ${INSTALL_ATUIN:-false}
        INSTALL_MISE: ${INSTALL_MISE:-false}
        INSTALL_ZELLIJ: ${INSTALL_ZELLIJ:-false}
        INSTALL_JUJUTSU: ${INSTALL_JUJUTSU:-false}

        # Whether to install Node.js, and the version wanted.
        # Note that a WebAssembly target is also automatically ready.
        #
        # Values can be:
        # - if `none`: don't install Node.js
        # - if `latest`: Install Ubuntu's default package for Node.js
        # - If anything else: The exact version to install (e.g. "1.90.0").
        #   That last type of value will only work if `INSTALL_MISE` is `true`.
        INSTALL_NODE: ${INSTALL_NODE:-none}

        # Whether to install Rust and Cargo, and the version wanted.
        # Note that a WebAssembly target is also automatically ready.
        #
        # Values can be:
        # - if `none`: don't install Rust
        # - if `latest`: Install Ubuntu's default package for Rust
        #   Ubuntu base's repositories
        # - If anything else: The exact version to install (e.g. "1.90.0").
        #   That last type of value will only work if `INSTALL_MISE` is `true`.
        INSTALL_RUST: ${INSTALL_RUST:-none}

        # Whether to install Python, and the version wanted.
        #
        # Values can be:
        # - if `none`: don't install Python
        # - if `latest`: Install Ubuntu's default package for Python
        # - If anything else: The exact version to install (e.g. "3.12.0").
        #   That last type of value will only work if `INSTALL_MISE` is `true`.
        INSTALL_PYTHON: ${INSTALL_PYTHON:-none}

        # Whether to install Go, and the version wanted.
        # Note that GOPATH is automatically set to ~/go
        #
        # Values can be:
        # - if `none`: don't install Go
        # - if `latest`: Install Ubuntu's default package for Go
        # - If anything else: The exact version to install (e.g. "1.21.5").
        #   That last type of value will only work if `INSTALL_MISE` is `true`.
        INSTALL_GO: ${INSTALL_GO:-none}

        # Add WebAssembly-specialized tools, such as `binaryen` and a
        # WebAssembly target for Rust if it is installed.
        ENABLE_WASM: ${ENABLE_WASM:-false}

        # If `true`, `openssh` will be installed, and the container will listen for ssh
        # connections at port 22.
        ENABLE_SSH: ${ENABLE_SSH:-false}

        # If `true`, `sudo` will be installed, (password set to `dev`).
        ENABLE_SUDO: ${ENABLE_SUDO:-false}

        # Git basic information.
        # Can also be empty to not set that in the container.
        GIT_AUTHOR_NAME: ${GIT_AUTHOR_NAME:-}
        GIT_AUTHOR_EMAIL: ${GIT_AUTHOR_EMAIL:-}

        # Additional packages outside the core base, separated by a space.
        # Have to be in Ubuntu's default repository
        # (e.g. "ripgrep fzf". Can be left empty for no supplementary packages)
        SUPPLEMENTARY_PACKAGES: ${SUPPLEMENTARY_PACKAGES:-}

        # Name of the project directory inside the container.
        PROJECT_DIRNAME: ${PROJECT_DIRNAME}

        # Path to the project you want to mount in this container
        # Will be mounted in `$HOME/projects/<PROJECT_DIRNAME>` inside that container.
        PROJECT_PATH: ${PROJECT_PATH}

    # Persistent volumes mounted. Those three are necessary, but you can add
    # supplementary ones with different access rules if you want.
    volumes:
      - ${PROJECT_PATH}:/home/${USERNAME:-dev}/projects/${PROJECT_DIRNAME}
      - shared-cache:/home/${USERNAME:-dev}/.container-cache
      - local-state:/home/${USERNAME:-dev}/.container-local
      # Git credentials for HTTPS auth
      # - ~/.git-credentials:/home/${USERNAME:-dev}/.git-credentials:ro

      # SSH keys for Git over SSH
      # - ~/.ssh:/home/${USERNAME:-dev}/.ssh:ro

      # AWS credentials
      # - ~/.aws:/home/${USERNAME:-dev}/.aws:ro

      # Custom CA certificates
      # - /etc/ssl/certs/custom-ca.crt:/usr/local/share/ca-certificates/custom-ca.crt:ro

      # Add your own:
      # - /host/path:/container/path:ro

      # NOTE: If `ENABLE_SSH` is set to `true`, you also want to link your host's
      # public key like so:
      # - ~/.ssh/PATH_TO_YOUR_KEY.pub:/etc/ssh/authorized_keys/${USERNAME}:ro
    working_dir: /home/${USERNAME:-dev}/projects/${PROJECT_DIRNAME}

  # Reset cache directory to its state at build-time.
  # The "cache directory" corresponds to cached data such as the one for
  # installed npm/yarn packages.
  # It can be shared through multiple containers simultaneously relatively safely.
  reset-cache:
    image: paulenv:${PROJECT_ID:-latest}
    pull_policy: never
    user: root
    command: >
      mkdir -p /mnt/cache &&
             sh -c "cp -a /home/${USERNAME}/.container-cache/. /mnt/cache/ &&
             chown -R ${HOST_UID}:${HOST_GID} /mnt/cache"
    volumes:
      - shared-cache:/mnt/cache
    environment:
      - USERNAME=${USERNAME:-dev}
      - HOST_UID=${HOST_UID:-1000}
      - HOST_GID=${HOST_GID:-1000}
    profiles: ["reset"]

  # Reset local directory to its state at build-time.
  # The "local directory" corresponds roughly to the `XDG_DATA_HOME` and
  # `XDG_STATE_HOME` directories (e.g. shell history, neovim plugins, tool data
  # and database etc.)
  # This volume is more concurrency-sensible and is thus mounted as separate
  # distinct volumes on multiple simultaneous containers (one per project).
  reset-local:
    image: paulenv:${PROJECT_ID:-latest}
    pull_policy: never
    user: root
    command: >
      mkdir -p /mnt/local &&
             sh -c "cp -a /home/${USERNAME}/.container-local/. /mnt/local/ &&
             chown -R ${HOST_UID}:${HOST_GID} /mnt/local"
    volumes:
      - local-state:/mnt/local
    environment:
      - USERNAME=${USERNAME:-dev}
      - HOST_UID=${HOST_UID:-1000}
      - HOST_GID=${HOST_GID:-1000}
    profiles: ["reset"]

volumes:
  shared-cache:
    name: paulenv-shared-cache
    external: true

  local-state:
    # Create project-specific volume with clean name
    name: ${COMPOSE_PROJECT_NAME}-local
